674.最长递增子数组
  子数组问题，dp或贪心直接求解。
300.最长递增子序列  ***
  dp[i]=max(dp[j])+1  {nums[i]>nums[j],0<=j<i}  dp[i]表示以nums[i]结束的最长递增子序列
718.最长重复子数组 *
  arr[i][j] = arr[i-1][j-1]+1 {nums1[i-1]==nums2[j-1]}; else arr[i][j]=0;
1143.最长公共子序列 *
  if(c1==text2.charAt(j-1)){
       arr[i][j] = arr[i-1][j-1]+1;
   }else{
       arr[i][j] = Math.max(arr[i-1][j],arr[i][j-1]);
   }
1035.不相交的线

53.最大子序和 ***
  a. 贪心： 和为负就抛弃从下一个开始记，否则不停更新max
     求子段：sum<0时，记录开始位置from=i+1；max更新时，清空记录，记录当前的开始位置from和结束位置(i)
  b. dp:    f(i)=max{f(i−1)+nums[i],nums[i]}
     求子段： tmp==nums[i]时，更新from，更新max时，记录to并插入结果。
392.判断子序列 b**
  a. 双指针
  b. dp: 令 f[i][j] 表示字符串 t 中从位置 i 开始往后字符 j 第一次出现的位置。如果 t中位置 i 的字符就是 j，那么 f[i][j]=i，否则 j 出现在位置 i+1 开始往后，即 f[i][j]=f[i+1][j]
115.不同的子序列  ****
  if(s.charAt(j-1)==chart)
    arr[i][j] = arr[i-1][j-1]+arr[i][j-1];
  else
    rr[i][j] = arr[i][j-1];
  以s为行，t为列（s需要匹配t）
583.两个字符串的删除操作
  直接用1143
  or dp 参考72
72.编辑距离 ****
  当 word1[i] == word2[j]，dp[i][j] = dp[i-1][j-1]；
  当 word1[i] != word2[j]，dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1
  其中，dp[i-1][j-1] 表示替换操作，dp[i-1][j] 表示删除操作，dp[i][j-1] 表示插入操作（插入和另一串删除等价）。
647.回文子串&&5. 最长回文子串 ***
  遍历串，然后中心拓展。
  关键点：统一中心是一个还是两个的情况；
  解决思路：设计一个两个中心的函数，函数使用双指针从中心左右开始遍历，边拓展边记录回文长度
  
516.最长回文子序列 ****
  if (c1 == c2) {
      dp[i][j] = dp[i + 1][j - 1] + 2;
  } else {
      dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
  }
  or 
  反转然后找LCS

