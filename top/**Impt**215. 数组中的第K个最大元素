//线性时间选择--随机取划分元
class Solution {
   public int findKthLargest(int[] nums, int k) {

        return select(nums,0,nums.length-1,k);
    }
     public int select(int[] a, int l, int r, int k){
        if(l==r) return a[l];
        int index = randPartion(a,l,r);
        int leftsize = index-l+1;
        int rightsize = r-l+1-leftsize;
        if(rightsize<k) return select(a,l,index,k-rightsize);
        else return select(a,index+1,r,k);
    }
    
    public int randPartion(int[] a, int l, int r){
        int x = new Random().nextInt(r - l + 1) + l;
        int i=l,j=r,tmp=a[x];
        swap(a,l,x);
        while(i<j){ //正确写法
            while(a[j]>=tmp&&i<j)
                j--;
            a[i]=a[j];
            while(a[i]<=tmp&&i<j)
                i++;
            a[j]=a[i];
        }
        a[j]=tmp;
        return j;
    }
    public void swap(int[] a,int i, int j){
        int tmp = a[j];
        a[j]=a[i];
        a[i]=tmp;
    }
}
//手写堆排序
//建堆：循环n次，每次调整o(log n)，故最好、最坏、平均情况下：o(n*logn);
class Solution {
   int[] a;
   int heapSize=0;
   public int findKthLargest(int[] nums, int k) {
        a = nums;
        heapSize = nums.length;
        for(int i=(heapSize-2)/2;i>=0;i--){
            buildDown(i);
        }
        for(int i=0;i<k-1;i++){
            pop(i);
        }
        return a[0];
    }
    public void buildDown(int k){
        if(heapSize==1||k>(heapSize-2)/2)
            return;
        int left = k*2+1, right = k*2+2, largest = left;
        if(right<heapSize && a[right]>a[left])
            largest = right;
        if(a[k]<a[largest]){
            swap(k,largest);
            buildDown(largest);
        }
    }
    public void pop(int k){
        swap(0,heapSize-1);
        heapSize--;
        buildDown(0);
    }
    public void swap(int i, int j){
        int tmp = a[j];
        a[j]=a[i];
        a[i]=tmp;
    }
}
//线性时间选择--中位数解法
class Solution {
   public int findKthLargest(int[] nums, int k) {

        return select(nums,0,nums.length-1,k);
    }
    public int select(int[] a, int p, int r, int k){
        if (r-p<5) {
            Arrays.sort(a,p,r+1);//sort 排序从p排序到r而并不是r+1
            return a[r-k+1];
        };
        for(int i=0;i<=(r-p-4)/5;i++){
            Arrays.sort(a,p+i*5,p+i*5+4);
            int med=p+i*5+2;
            swap(a,p+i,med); //各组中位数交换到数组前面的位置
        }
        int x = select(a, p, p+(r-p-4)/5, (r-p+1)/10);
        int i=partition(a,p,r, x);
        int j=r-i+1;  //划分元+划分元右边元素个数
        if (k<=j) return select(a,i,r,k);//在右边，k不变
        else return select(a,p,i-1,k-j);//在右边，k变为k-j
    }
   public int partition(int[] a,int p,int r,int val)
    {
        int pos=0;
        for(int q=p; q<=r; q++)
        {
            if(a[q]==val)
            {
                pos=q;
                break;
            }
        }
        swap(a,p,pos);

        int i=p,j=r+1,x=a[p];
        while(true)   //写法有问题？
        {
            while(a[++i]<x&&i<r);
            while(a[--j]>x);
            if(i>=j)break;
            swap(a,i,j);
        }
        a[p]=a[j];
        a[j]=x;
        return j;
    }
    public void swap(int[] a, int i, int j){
        int tmp = a[j];
        a[j]=a[i];
        a[i]=tmp;
    }
}
