//错了 主要看遍历map的方法（顺序和逆序）
class Solution {
    public int longestSubstring(String s, int k) {
        Map<Character,Integer> m = new LinkedHashMap<>();
        int len = s.length();
        int res  = 0;
        if(k==1) return len;
        for(int i=0;i<len;i++){
            char c = s.charAt(i);
            if(m.containsKey(c)){
                int count = m.get(c)-1;
                m.remove(c);
                m.put(c,count);
                Set<Map.Entry<Character,Integer>> set = m.entrySet();
                Iterator<Map.Entry<Character,Integer>> li =set.iterator();
                int length = 0;
                // ListIterator<Map.Entry<Character,Integer>> li=new ArrayList<Map.Entry<Character,Integer>>(m.entrySet()).listIterator(m.size()); //逆序遍历Linkedmap只能采用List
                while(li.hasNext()){
                    Map.Entry<Character,Integer> me = li.next();
                    if(me.getValue()<=0)
                        length+=k-me.getValue();
                    else
                        break;
                }
                res = Math.max(res,length);
            }
            else
                m.put(c,k-1);
        }
        return res;
    }
}
class Solution {
    public int longestSubstring(String s, int k) {
        if (s.length() < k) return 0;
        HashMap<Character, Integer> counter = new HashMap();
        for (int i = 0; i < s.length(); i++) {
            counter.put(s.charAt(i), counter.getOrDefault(s.charAt(i), 0) + 1);
        }
        for (char c : counter.keySet()) {
            if (counter.get(c) < k) {
                int res = 0;
                for (String t : s.split(String.valueOf(c))) {
                    res = Math.max(res, longestSubstring(t, k));
                }
                return res;
            }
        }
        return s.length();
    }
}
