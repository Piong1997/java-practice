#稳定的算法：冒泡、直接插入、归并
#直接插入排序
public int[] sortArray(int[] nums) {
        for(int i=1;i<nums.length;i++){
            int tmp=nums[i];
            int j=i-1;
            for(;j>=0&&nums[j]>tmp;j--){//把前面的数与当前数比较，比当前数大就往后移一位
                nums[j+1] = nums[j];//往后移一位
            }
            nums[j+1] = tmp;//j+1就是当前数应该在的位置
        }
        return nums;
}
#选择排序
public int[] sortArray(int[] nums) {
for(int i=0;i<nums.length-1;i++){
    int min = i;
    for(int j=i+1;j<nums.length;j++){ //对每个位置后面的元素，找到最小值
        min = nums[j]<nums[min]?j:min;
    }
    int tmp = nums[i];//最小值和i交换
    nums[i] = nums[min];
    nums[min] = tmp;
}
return nums;
}
#2路归并排序
 public int[] sortArray(int[] nums) {
        return sort(nums,0,nums.length-1);
    }
    public int[] sort(int[] a,int low,int high){
        int mid = low+(high-low)/2;
        if(low<high){
            sort(a,low,mid);
            sort(a,mid+1,high);
            merge(a,low,mid,high);
        }
        return a;
    }
    public void merge(int[] a,int low, int mid, int high){
        int i=low,j=mid+1,index=0;
        int[] tmp = new int[high-low+1];
        // 把较小的数先移到新数组中
        while(i<=mid && j<=high){
            if(a[i]<=a[j])   //这里用<=保证相等情况下先用前面的，保证了排序的稳定性
                tmp[index++]=a[i++];
            else
                tmp[index++]=a[j++];
        }
        // 把左边剩余的数移入数组 
        while(i<=mid){
            tmp[index++] = a[i++];
        }
        // 把右边边剩余的数移入数组
        while(j<=high){
            tmp[index++] = a[j++];
        }
        // 把新数组中的数覆盖nums数组
         for(int x=0;x<tmp.length;x++){
            a[x+low] = tmp[x];
        }
    }
