//102
class Solution {
   public List<List<Integer>> levelOrder(TreeNode root) {
    if(root == null)
        return new ArrayList<>();
    List<List<Integer>> res = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.add(root);
    while(!queue.isEmpty()){
        int count = queue.size(); //设置count记录当前层节点数量
        List<Integer> list = new ArrayList<Integer>();
        while(count > 0){ //二层循环，遍历完当前层节点
            TreeNode node = queue.poll();
            list.add(node.val);
            if(node.left != null)
                queue.add(node.left);
            if(node.right != null)
                queue.add(node.right);
            count--;
        }
        res.add(list);
    }
    return res;
   }
}
//103
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> tmpRes = new ArrayList<>();
        Queue<TreeNode> dq = new LinkedList<>();
        int layer = 1;
        if(root == null) return res;
        dq.offer(root);
        while(!dq.isEmpty()){
            int count = dq.size();
            while(count>0){
                TreeNode t = dq.poll();
                tmpRes.add(t.val);
                if(t.left!=null) dq.offer(t.left);
                if(t.right!=null) dq.offer(t.right);
                count--;
            }
            if((layer&1)==1)
                res.add(new ArrayList(tmpRes));
            else{
                Collections.reverse(tmpRes);
                res.add(new ArrayList(tmpRes));
            }
            tmpRes.clear();
            layer++;
        }
        return res;
    }
}
//103
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> tmpRes = new ArrayList<>();
        Deque<TreeNode> dq = new LinkedList<>();
        Deque<TreeNode> tmpDq = new LinkedList<>();
        int layer = 1;
        if(root == null) return res;
        dq.offerLast(root);
        while(!dq.isEmpty()){
            TreeNode t = dq.pollFirst();
            tmpRes.add(t.val);
            if(t.left!=null) tmpDq.offerLast(t.left);
            if(t.right!=null) tmpDq.offerLast(t.right);
            if(dq.isEmpty()){
                if((layer&1)==1)
                    res.add(new ArrayList(tmpRes));
                else{
                    Collections.reverse(tmpRes);
                    res.add(new ArrayList(tmpRes));
                }
                layer++;
                tmpRes.clear();
                Deque<TreeNode> tmp = tmpDq;
                tmpDq = dq;
                dq = tmp;
            }
        }
        return res;
    }
}
