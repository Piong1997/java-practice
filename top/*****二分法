剑指 Offer II 068. 查找插入位置    
public int searchInsert(int[] nums, int target) {
        int mid = 0;
        int res = 0;
        for(int left=0,right=nums.length-1;left<=right;){
            mid = (left+right)/2;
            if(nums[mid]==target) return mid;
            else if(nums[mid]<target){
                left = mid+1;
                res = left;
            }
            else{ 
                right = mid - 1;
                res = right+1;
            }
        }
        return res;
    }
}
//704 二分查找
class Solution {
    public int search(int[] nums, int target) {
        int low=0,high=nums.length,mid=0;// 定义target在左闭右开的区间里，即：[left, right)
        while(low<high){// 因为left == right的时候，在[low, high)是无效的空间，所以使用 <
            mid=(low+high)/2;
            if(nums[mid]>target)
                high=mid;// target 在左区间，在[low, mid)中
            else if(nums[mid]<target)
                low=mid+1;// target 在右区间，在[mid + 1, high)中
            else
                return mid;
        }
        return -1;
    }
}
//410. 分割数组的最大值
class Solution {
    public int splitArray(int[] nums, int m) {
        //low是分割数组和的最大值的下界，为数组元素最大值
        //high是分割数组和的最大值的上界，为所有元素和（不分割）
        int low=0,high=0;
        for(int i=0;i<nums.length;i++){
            high += nums[i];
            low = Math.max(low,nums[i]);
        }
        int mid = 0 ;
        //二分的条件都是左边界小于右边界
        while(low<high){
            mid = (low+high)/2;
            int tmp = 0;
            //count为划分数组个数，最小为1
            int count = 1;
            for(int i=0;i<nums.length;i++){
                tmp=tmp+nums[i];
                if(tmp>mid){
                    count++;
                    tmp = nums[i];
                }
            }
            //count大于m，说明当前mid小了，导致划分出了更多的数组，low=mid
            if(count>m)
                low = mid+1;
            //否则count<m或者=m，
            //count<m，说明当前mid大了，导致划分出了更少的数组，让high=mid
            //count=m，说明当前mid合适，要继续减小mid，等价于继续减小high，
            //让high=mid而不是high=mid-1，因为 mid 是一个已经满足条件的值了，我们需要将它保留（如果更小的mid都不满足，那么在low==high的时候mid还会取到一次当前的mid）
            else 
                high = mid;
        }
        return low;
    }
}

//875. 爱吃香蕉的珂珂
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int low=0,high=0,sum=0,mid=0;
        for(int i=0;i<piles.length;i++){
            sum += piles[i];
            high = Math.max(high,piles[i]);
        }
        low = sum%h==0?sum/h:sum/h+1;
        while(low<high){
            mid = (low+high)/2;
            int count = 0;
            for(int i=0;i<piles.length;i++){
                int add = piles[i]%mid==0?piles[i]/mid:piles[i]/mid+1;
                count+=add;
            }
            if(count>h) 
                low=mid+1;
            else
                high=mid;
        }
        return low;
    }
}
